#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform UniformBufferObject {
    vec2 corners[4]; // TL, TR, BL, BR corners in normalized coordinates
    vec2 textureSize; // Size of the texture for normalization
};

layout(binding = 1, rgba8) uniform readonly image2D inputImage;
layout(binding = 2, rgba8) uniform writeonly image2D outputImage;

// Helper function to perform bilinear interpolation
vec4 bilinearSample(vec2 uv) {
    // Compute texture coordinates in pixel space
    vec2 pixelCoord = uv * textureSize;
    
    // Get the four surrounding pixel coordinates
    ivec2 p00 = ivec2(floor(pixelCoord));
    ivec2 p10 = ivec2(p00.x + 1, p00.y);
    ivec2 p01 = ivec2(p00.x, p00.y + 1);
    ivec2 p11 = ivec2(p00.x + 1, p00.y + 1);
    
    // Ensure we don't read outside the texture bounds
    p00 = clamp(p00, ivec2(0), ivec2(textureSize) - ivec2(1));
    p10 = clamp(p10, ivec2(0), ivec2(textureSize) - ivec2(1));
    p01 = clamp(p01, ivec2(0), ivec2(textureSize) - ivec2(1));
    p11 = clamp(p11, ivec2(0), ivec2(textureSize) - ivec2(1));
    
    // Get interpolation factors
    vec2 f = fract(pixelCoord);
    
    // Sample the four pixels
    vec4 c00 = imageLoad(inputImage, p00);
    vec4 c10 = imageLoad(inputImage, p10);
    vec4 c01 = imageLoad(inputImage, p01);
    vec4 c11 = imageLoad(inputImage, p11);
    
    // Bilinear interpolation
    vec4 cx0 = mix(c00, c10, f.x);
    vec4 cx1 = mix(c01, c11, f.x);
    return mix(cx0, cx1, f.y);
}

// Helper function to determine if a point is inside a quadrilateral using cross products
bool isInsideQuad(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {
    // Check if the point is on the same side of all four edges
    vec2 ab = b - a;
    vec2 ap = p - a;
    float cross_ab_ap = ab.x * ap.y - ab.y * ap.x;
    
    vec2 bc = c - b;
    vec2 bp = p - b;
    float cross_bc_bp = bc.x * bp.y - bc.y * bp.x;
    
    vec2 cd = d - c;
    vec2 cp = p - c;
    float cross_cd_cp = cd.x * cp.y - cd.y * cp.x;
    
    vec2 da = a - d;
    vec2 dp = p - d;
    float cross_da_dp = da.x * dp.y - da.y * dp.x;
    
    // All cross products must have the same sign
    return (cross_ab_ap > 0.0 && cross_bc_bp > 0.0 && cross_cd_cp > 0.0 && cross_da_dp > 0.0) ||
           (cross_ab_ap < 0.0 && cross_bc_bp < 0.0 && cross_cd_cp < 0.0 && cross_da_dp < 0.0);
}

// Compute the barycentric coordinates for a point in a quadrilateral
vec2 computeQuadTexCoord(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {
    // Initialize s and t to a reasonable guess (center of quad)
    vec2 st = vec2(0.5, 0.5);
    
    // Perform a few iterations to refine the coordinates
    for (int i = 0; i < 4; i++) {
        float s = st.x;
        float t = st.y;
        
        // Compute the position using the current s,t
        vec2 pos = (1.0-s)*(1.0-t)*a + s*(1.0-t)*b + s*t*c + (1.0-s)*t*d;
        
        // Compute the error
        vec2 error = p - pos;
        
        // Compute the Jacobian (partial derivatives)
        vec2 ds = (1.0-t)*(b-a) + t*(c-d);
        vec2 dt = (1.0-s)*(d-a) + s*(c-b);
        
        // Compute determinant of Jacobian
        float det = ds.x*dt.y - ds.y*dt.x;
        
        // Update s and t (inverse Jacobian multiplied by error)
        if (abs(det) > 0.0001) {
            st += vec2(dt.y*error.x - dt.x*error.y, -ds.y*error.x + ds.x*error.y) / det;
            
            // Clamp s and t to [0,1]
            st = clamp(st, vec2(0.0), vec2(1.0));
        }
    }
    
    return st;
}

void main() {
    // Get the current pixel coordinate
    ivec2 outputCoord = ivec2(gl_GlobalInvocationID.xy);
    
    // Make sure we're within bounds
    if (outputCoord.x >= int(textureSize.x) || outputCoord.y >= int(textureSize.y)) {
        return;
    }
    
    // Convert to normalized coordinates [0,1]
    vec2 normalizedCoord = vec2(outputCoord) / textureSize;
    
    // Check if this pixel is inside the keystone quad
    if (isInsideQuad(normalizedCoord, corners[0], corners[1], corners[3], corners[2])) {
        // Compute texture coordinates using projective mapping
        vec2 st = computeQuadTexCoord(normalizedCoord, corners[0], corners[1], corners[3], corners[2]);
        
        // Sample from the input image using bilinear interpolation
        vec4 color = bilinearSample(st);
        
        // Write to the output image
        imageStore(outputImage, outputCoord, color);
    } else {
        // Outside the keystone quad, write transparent black
        imageStore(outputImage, outputCoord, vec4(0.0, 0.0, 0.0, 0.0));
    }
}